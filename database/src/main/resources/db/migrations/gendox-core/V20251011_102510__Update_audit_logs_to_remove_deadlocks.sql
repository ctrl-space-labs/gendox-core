-- Job document_splitter is creating deadlocks involving audit_logs x document_instance tables
-- When inserting in parallel in those 2 tables, the tables that FK constraints point to are locked with FOR KEY SHARE
-- in different orders, causing a deadlock.

-- Delete all audit_logs FK constraints, they are not needed for audit logs and dont want to add indexed to columns
-- that will drastically decrease the performance of inserts in audit_logs

-- We are taking the risk to have orphan audit_logs in case of deletions in the parent tables, but audit logs are not critical data

ALTER TABLE gendox_core.audit_logs DROP CONSTRAINT IF EXISTS audit_logs_created_by_fkey;
ALTER TABLE gendox_core.audit_logs DROP CONSTRAINT IF EXISTS audit_logs_updated_by_fkey;
ALTER TABLE gendox_core.audit_logs DROP CONSTRAINT IF EXISTS message_logs_user_id_fkey;
ALTER TABLE gendox_core.audit_logs DROP CONSTRAINT IF EXISTS message_logs_project_id_fkey;
ALTER TABLE gendox_core.audit_logs DROP CONSTRAINT IF EXISTS audit_logs_type_id_fkey;

ALTER TABLE gendox_core.audit_logs
    ADD CONSTRAINT audit_logs_type_id_fkey
        FOREIGN KEY (type_id) REFERENCES gendox_core.types(id)
            DEFERRABLE INITIALLY DEFERRED;


-- When inserting in audit_logs, we will now insert a row in audit_log_queue
-- A separate process (Spring Boot trigger) will read from that queue and update organization_daily_usage
CREATE TABLE IF NOT EXISTS gendox_core.audit_log_queue
(
    id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    audit_log_id BIGINT      NOT NULL, -- points to audit_logs.id (bigint)
    created_at   timestamptz NOT NULL DEFAULT now()
);

CREATE OR REPLACE FUNCTION gendox_core.enqueue_audit_log_id()
    RETURNS TRIGGER AS $$
BEGIN
    -- NEW.id is BIGINT now
    INSERT INTO gendox_core.audit_log_queue(audit_log_id)
    VALUES (NEW.id);
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Drop the old trigger if it exists
DROP TRIGGER IF EXISTS trg_update_organization_daily_usage ON gendox_core.audit_logs;

DO $$
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_enqueue_audit_log_id') THEN
            DROP TRIGGER trg_enqueue_audit_log_id ON gendox_core.audit_logs;
        END IF;

        CREATE TRIGGER trg_enqueue_audit_log_id
            AFTER INSERT ON gendox_core.audit_logs
            FOR EACH ROW
        EXECUTE FUNCTION gendox_core.enqueue_audit_log_id();
    END;
$$;


CREATE TABLE IF NOT EXISTS gendox_core.shedlock
(
    name       VARCHAR(64),
    lock_until TIMESTAMP(3) NULL,
    locked_at  TIMESTAMP(3) NULL,
    locked_by  VARCHAR(255),
    PRIMARY KEY (name)
)
-- Update the trigger function to execute only one INSERT ... ON CONFLICT ... DO UPDATE statement per audit log insert
-- CREATE OR REPLACE FUNCTION gendox_core.update_organization_daily_usage()
--     RETURNS TRIGGER AS $$
-- DECLARE
--     completion_response_type_id bigint;
--     document_create_type_id     bigint;
--     document_delete_type_id     bigint;
--     document_sections_type_id   bigint;
--
--     d_messages        integer := 0;
--     d_doc_uploads     integer := 0;
--     d_doc_sections    integer := 0;
--     d_storage_mb      bigint  := 0;
--     audit_value       bigint;
-- BEGIN
--
--     -- Cache type ids
--     SELECT id INTO completion_response_type_id
--     FROM gendox_core.types WHERE type_category='AUDIT_LOG_TYPE' AND name='COMPLETION_RESPONSE';
--     SELECT id INTO document_create_type_id
--     FROM gendox_core.types WHERE type_category='AUDIT_LOG_TYPE' AND name='DOCUMENT_CREATE';
--     SELECT id INTO document_delete_type_id
--     FROM gendox_core.types WHERE type_category='AUDIT_LOG_TYPE' AND name='DOCUMENT_DELETE';
--     SELECT id INTO document_sections_type_id
--     FROM gendox_core.types WHERE type_category='AUDIT_LOG_TYPE' AND name='CREATE_DOCUMENT_SECTIONS';
--
--     audit_value := COALESCE(NEW.audit_value, 0);
--
--     IF NEW.type_id = completion_response_type_id THEN
--         d_messages := d_messages + 1;
--     END IF;
--
--     IF NEW.type_id = document_create_type_id THEN
--         d_doc_uploads := d_doc_uploads + 1;
--         d_storage_mb  := d_storage_mb  + audit_value;
--     END IF;
--
--     IF NEW.type_id = document_delete_type_id THEN
--         d_doc_uploads := d_doc_uploads - 1;
--         d_storage_mb  := d_storage_mb  - audit_value;
--     END IF;
--
--     IF NEW.type_id = document_sections_type_id THEN
--         d_doc_sections := d_doc_sections + 1;
--     END IF;
--
--     -- If nothing to change, exit early
--     IF d_messages = 0 AND d_doc_uploads = 0 AND d_doc_sections = 0 AND d_storage_mb = 0 THEN
--         RETURN NEW;
--     END IF;
--
--     -- Single upsert (touches the row once)
--     INSERT INTO gendox_core.organization_daily_usage
--     (organization_id, date, messages, document_uploads, document_sections, storage_mb)
--     VALUES
--         (NEW.organization_id, NEW.created_at::date, d_messages, d_doc_uploads, d_doc_sections, d_storage_mb)
--     ON CONFLICT (organization_id, date) DO UPDATE
--         SET messages         = gendox_core.organization_daily_usage.messages + EXCLUDED.messages,
--             document_uploads = gendox_core.organization_daily_usage.document_uploads + EXCLUDED.document_uploads,
--             document_sections= gendox_core.organization_daily_usage.document_sections + EXCLUDED.document_sections,
--             storage_mb       = gendox_core.organization_daily_usage.storage_mb + EXCLUDED.storage_mb;
--
--     RETURN NEW;
-- END;
-- $$ LANGUAGE plpgsql;

-- DO $$
--     BEGIN
--         IF EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_update_organization_daily_usage') THEN
--             DROP TRIGGER trg_update_organization_daily_usage ON gendox_core.audit_logs;
--         END IF;
--
--         CREATE TRIGGER trg_update_organization_daily_usage
--             AFTER INSERT ON gendox_core.audit_logs
--             FOR EACH ROW
--         EXECUTE FUNCTION gendox_core.update_organization_daily_usage();
--     END;
-- $$;
